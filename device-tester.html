<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClassTech Testing</title>
    <link rel="shortcut icon" href="https://cdn.brand.illinois.edu/favicon.ico">
    <link rel="stylesheet" href="https://cdn.brand.illinois.edu/illinois.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --accent: #ff5f05;
            --accent-dim: #e65100;
            --text-primary: #13294b;
            --text-secondary: #5a5a5a;
            --border: #e0e0e0;
            --error: #d32f2f;
            --success: #2e7d32;
        }

        body {
            font-family: var(--il-font-sans, 'Montserrat', sans-serif);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid var(--accent);
            margin-bottom: 30px;
        }

        h1 {
            font-family: var(--il-font-heading, 'Montserrat', sans-serif);
            font-size: 2.5rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 95, 5, 0.5);
            font-weight: 700;
        }

        .chicago-time {
            font-size: 1.8rem;
            color: var(--text-primary);
            font-weight: bold;
            margin-top: 10px;
            font-family: var(--il-font-sans, 'Montserrat', sans-serif);
        }

        .sync-section {
            background: var(--bg-secondary);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .sync-section h2 {
            font-family: var(--il-font-heading, 'Montserrat', sans-serif);
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .sync-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .room-code {
            font-size: 1.5rem;
            background: var(--bg-primary);
            color: var(--accent);
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid var(--accent);
            font-weight: bold;
        }

        input[type="text"] {
            background: var(--bg-primary);
            border: 2px solid var(--border);
            color: var(--text-primary);
            padding: 10px 15px;
            border-radius: 5px;
            font-family: var(--il-font-sans, 'Montserrat', sans-serif);
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        button {
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: var(--il-font-sans, 'Montserrat', sans-serif);
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        button:hover {
            background: var(--accent-dim);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 95, 5, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .status {
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        .status.connected {
            background: var(--success);
            color: var(--bg-primary);
        }

        .status.disconnected {
            background: var(--error);
            color: var(--text-primary);
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            transition: border-color 0.3s;
        }

        .test-card:hover {
            border-color: var(--accent);
        }

        .test-card h3 {
            font-family: var(--il-font-heading, 'Montserrat', sans-serif);
            color: var(--accent);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 1.1rem;
        }

        video, audio {
            width: 100%;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 5px;
            margin-bottom: 15px;
        }

        video {
            max-height: 300px;
        }

        select {
            width: 100%;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 5px;
            font-family: var(--il-font-sans, 'Montserrat', sans-serif);
            margin-bottom: 10px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .info-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .device-info {
            background: var(--bg-primary);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .controls button {
            flex: 1;
            min-width: 120px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            
            .test-grid {
                grid-template-columns: 1fr;
            }
            
            .sync-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="https://illinois.edu/wp-content/themes/illinois/assets/Illinois_primary_wordmark_fullcolor_rgb.png" alt="University of Illinois" style="height: 60px; margin-bottom: 20px;">
            <h1>üîß ClassTech Testing</h1>
            <div class="chicago-time" id="chicago-time">--:--:-- CT</div>
        </header>

        <div class="sync-section">
            <h2>üîó Cross-Device Sync</h2>
            <div class="sync-controls">
                <div>
                    <span style="color: var(--text-secondary);">Room Code:</span>
                    <span class="room-code" id="room-code">XXXX</span>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <input type="text" id="join-code" placeholder="Enter room code..." maxlength="4">
                    <button onclick="joinRoom()">Join Room</button>
                    <button onclick="createRoom()">Create New Room</button>
                </div>
                <div class="status disconnected" id="sync-status">Disconnected</div>
            </div>
            <div class="info-text">
                üí° Devices in the same room will play synchronized audio/video sources for A/B testing
            </div>
        </div>

        <div class="test-grid">
            <!-- Camera Test -->
            <div class="test-card">
                <h3>üì∑ Camera Test</h3>
                <video id="camera-preview" autoplay playsinline muted></video>
                <select id="camera-select">
                    <option value="">Select Camera...</option>
                </select>
                <div class="controls">
                    <button onclick="startCamera()">Start Camera</button>
                    <button onclick="stopCamera()">Stop Camera</button>
                </div>
                <div class="device-info" id="camera-info">No camera active</div>
            </div>

            <!-- Microphone Test -->
            <div class="test-card">
                <h3>üé§ Microphone Test</h3>
                <div style="background: var(--bg-primary); padding: 20px; border-radius: 5px; margin-bottom: 15px;">
                    <div style="height: 100px; display: flex; align-items: center; justify-content: center;">
                        <canvas id="audio-visualizer" width="300" height="80"></canvas>
                    </div>
                </div>
                <select id="microphone-select">
                    <option value="">Select Microphone...</option>
                </select>
                <div class="controls">
                    <button onclick="startMicrophone()">Start Mic</button>
                    <button onclick="stopMicrophone()">Stop Mic</button>
                </div>
                <div class="device-info" id="mic-info">No microphone active</div>
            </div>

            <!-- Synced Video Test -->
            <div class="test-card">
                <h3>üé¨ Synced Video Test</h3>
                <video id="test-video" controls></video>
                <input type="text" id="video-url" placeholder="Enter video URL..." value="https://uofi.box.com/shared/static/6f6jiu539qsiommkx8qg0cgslq7a1bhm.mp4" style="width: 100%; margin-bottom: 10px;">
                <div class="controls">
                    <button onclick="loadVideo()">Load Video</button>
                    <button onclick="syncPlay()">Sync Play</button>
                    <button onclick="syncPause()">Sync Pause</button>
                </div>
                <div class="info-text">
                    üí° Use a public video URL (MP4, WebM, etc.)
                </div>
            </div>

            <!-- Device Info -->
            <div class="test-card">
                <h3>‚ÑπÔ∏è Device Information</h3>
                <div class="device-info" id="device-info" style="line-height: 1.8;">
                    Loading device info...
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebSocket Configuration - AWS API Gateway WebSocket endpoint
        const WEBSOCKET_URL = 'wss://myc0vhsind.execute-api.us-east-1.amazonaws.com/prod';

        // WebRTC Configuration
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ];

        let currentRoom = null;
        let ws = null;
        let isConnected = false;
        let myPeerId = null;

        // WebRTC P2P connections
        let peerConnections = new Map(); // peerId -> RTCPeerConnection
        let dataChannels = new Map(); // peerId -> RTCDataChannel
        let pendingIceCandidates = new Map(); // peerId -> [candidates]

        // Generate random 4-character room code
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 6).toUpperCase();
        }

        function connectWebSocket(roomCode) {
            if (ws) {
                ws.close();
            }

            // Generate unique peer ID for this device
            myPeerId = Math.random().toString(36).substring(2, 15);
            console.log('My Peer ID:', myPeerId);

            // Check if WebSocket URL is configured
            if (WEBSOCKET_URL === 'YOUR_WEBSOCKET_URL_HERE') {
                console.warn('WebSocket URL not configured, using localStorage fallback');
                useFallbackSync(roomCode);
                return;
            }

            document.getElementById('sync-status').textContent = 'Connecting...';
            document.getElementById('sync-status').className = 'status disconnected pulse';

            const wsUrl = `${WEBSOCKET_URL}?roomCode=${roomCode}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                isConnected = true;
                updateConnectionStatus();

                // Announce presence for WebRTC peer discovery
                sendSignaling({
                    type: 'join',
                    peerId: myPeerId
                });
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                console.log('Message received:', message);

                // Handle WebRTC signaling messages
                if (message.signaling) {
                    handleWebRTCSignaling(message);
                } else {
                    // Regular sync message (fallback if WebRTC not established)
                    handleSyncMessage(message);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('sync-status').textContent = 'Connection Error';
                document.getElementById('sync-status').className = 'status disconnected';
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                isConnected = false;
                // Close all peer connections
                peerConnections.forEach(pc => pc.close());
                peerConnections.clear();
                dataChannels.clear();
                updateConnectionStatus();
            };
        }

        // Update connection status display
        function updateConnectionStatus() {
            const p2pCount = dataChannels.size;
            if (p2pCount > 0) {
                document.getElementById('sync-status').textContent = `P2P Connected (${p2pCount})`;
                document.getElementById('sync-status').className = 'status connected';
            } else if (isConnected) {
                document.getElementById('sync-status').textContent = 'Connected (Signaling)';
                document.getElementById('sync-status').className = 'status connected';
            } else {
                document.getElementById('sync-status').textContent = 'Disconnected';
                document.getElementById('sync-status').className = 'status disconnected';
            }
        }

        // WebRTC Signaling Functions
        function sendSignaling(data) {
            if (!ws || !isConnected) return;

            const message = {
                action: 'message',
                roomCode: currentRoom,
                signaling: true,
                ...data
            };
            ws.send(JSON.stringify(message));
        }

        async function handleWebRTCSignaling(message) {
            const { type, peerId, offer, answer, candidate } = message;

            // Ignore messages from ourselves
            if (peerId === myPeerId) return;

            console.log('WebRTC signaling:', type, 'from', peerId);

            switch (type) {
                case 'join':
                    // New peer joined - initiate connection if we have lower peerId (to avoid duplicates)
                    if (myPeerId < peerId) {
                        console.log('Initiating connection to', peerId);
                        await createPeerConnection(peerId, true);
                    }
                    break;

                case 'offer':
                    await handleOffer(peerId, offer);
                    break;

                case 'answer':
                    await handleAnswer(peerId, answer);
                    break;

                case 'ice-candidate':
                    await handleIceCandidate(peerId, candidate);
                    break;
            }
        }

        async function createPeerConnection(peerId, isInitiator) {
            if (peerConnections.has(peerId)) {
                console.log('Connection to', peerId, 'already exists');
                return;
            }

            console.log('Creating peer connection to', peerId, 'initiator:', isInitiator);

            const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            peerConnections.set(peerId, pc);
            pendingIceCandidates.set(peerId, []);

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to', peerId);
                    sendSignaling({
                        type: 'ice-candidate',
                        peerId: myPeerId,
                        candidate: event.candidate
                    });
                }
            };

            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log('Connection state with', peerId, ':', pc.connectionState);
                if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    peerConnections.delete(peerId);
                    dataChannels.delete(peerId);
                    updateConnectionStatus();
                }
            };

            if (isInitiator) {
                // Create data channel
                const channel = pc.createDataChannel('sync', { ordered: false, maxRetransmits: 0 });
                setupDataChannel(peerId, channel);

                // Create and send offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                console.log('Sending offer to', peerId);
                sendSignaling({
                    type: 'offer',
                    peerId: myPeerId,
                    offer: offer
                });
            } else {
                // Wait for data channel from initiator
                pc.ondatachannel = (event) => {
                    console.log('Received data channel from', peerId);
                    setupDataChannel(peerId, event.channel);
                };
            }

            return pc;
        }

        function setupDataChannel(peerId, channel) {
            console.log('Setting up data channel for', peerId);

            channel.onopen = () => {
                console.log('DataChannel opened with', peerId);
                dataChannels.set(peerId, channel);
                updateConnectionStatus();

                // Send current media state to new peer so they can catch up
                const currentState = getCurrentMediaState();
                if (currentState.hasMedia) {
                    console.log('üì§ Sending current state to new peer:', peerId, currentState);
                    channel.send(JSON.stringify({
                        syncAction: 'sync-state',
                        ...currentState
                    }));
                }
            };

            channel.onclose = () => {
                console.log('DataChannel closed with', peerId);
                dataChannels.delete(peerId);
                updateConnectionStatus();
            };

            channel.onerror = (error) => {
                console.error('DataChannel error with', peerId, error);
            };

            channel.onmessage = (event) => {
                const message = JSON.parse(event.data);
                console.log('P2P message from', peerId, ':', message);
                handleSyncMessage(message);
            };
        }

        // Get current playback state for syncing new peers
        function getCurrentMediaState() {
            const video = document.getElementById('test-video');
            const videoUrl = document.getElementById('video-url').value;

            const state = {
                hasMedia: false
            };

            // Check video state
            if (video.src && videoUrl) {
                state.hasMedia = true;
                state.mediaType = 'video';
                state.url = videoUrl;
                state.currentTime = video.currentTime;
                state.isPlaying = !video.paused;
                state.duration = video.duration;
            }

            return state;
        }

        async function handleOffer(peerId, offer) {
            const pc = await createPeerConnection(peerId, false);
            await pc.setRemoteDescription(new RTCSessionDescription(offer));

            // Process any pending ICE candidates
            const pending = pendingIceCandidates.get(peerId) || [];
            for (const candidate of pending) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
            pendingIceCandidates.set(peerId, []);

            // Create and send answer
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log('Sending answer to', peerId);
            sendSignaling({
                type: 'answer',
                peerId: myPeerId,
                answer: answer
            });
        }

        async function handleAnswer(peerId, answer) {
            const pc = peerConnections.get(peerId);
            if (!pc) {
                console.error('No peer connection for', peerId);
                return;
            }
            await pc.setRemoteDescription(new RTCSessionDescription(answer));

            // Process any pending ICE candidates
            const pending = pendingIceCandidates.get(peerId) || [];
            for (const candidate of pending) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
            pendingIceCandidates.set(peerId, []);
        }

        async function handleIceCandidate(peerId, candidate) {
            const pc = peerConnections.get(peerId);
            if (!pc) {
                console.log('Peer connection not ready, queuing ICE candidate');
                const pending = pendingIceCandidates.get(peerId) || [];
                pending.push(candidate);
                pendingIceCandidates.set(peerId, pending);
                return;
            }

            if (pc.remoteDescription) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } else {
                const pending = pendingIceCandidates.get(peerId) || [];
                pending.push(candidate);
                pendingIceCandidates.set(peerId, pending);
            }
        }

        // Fallback to localStorage for local testing
        function useFallbackSync(roomCode) {
            currentRoom = roomCode;
            localStorage.setItem('av-tester-room', currentRoom);
            window.addEventListener('storage', handleStorageSync);
            document.getElementById('sync-status').textContent = 'Local Mode';
            document.getElementById('sync-status').className = 'status connected';
        }

        function createRoom() {
            currentRoom = generateRoomCode();
            document.getElementById('room-code').textContent = currentRoom;
            connectWebSocket(currentRoom);
        }

        function joinRoom() {
            const code = document.getElementById('join-code').value.toUpperCase();
            if (code.length === 4) {
                currentRoom = code;
                document.getElementById('room-code').textContent = currentRoom;
                connectWebSocket(currentRoom);
            } else {
                alert('Please enter a 4-character room code');
            }
        }

        function broadcastSync(action, mediaType, data = {}) {
            if (!currentRoom) {
                console.log('Not in a room, skipping sync');
                return;
            }

            const message = {
                syncAction: action,
                mediaType: mediaType,
                timestamp: Date.now(),
                ...data
            };

            // Prefer WebRTC DataChannels for ultra-low latency
            if (dataChannels.size > 0) {
                const msgStr = JSON.stringify(message);
                let sent = 0;
                dataChannels.forEach((channel, peerId) => {
                    if (channel.readyState === 'open') {
                        channel.send(msgStr);
                        sent++;
                    }
                });
                console.log(`üì° Sent via P2P DataChannel to ${sent} peers:`, message);
                return;
            }

            // Fallback to WebSocket if no P2P connections yet
            if (ws && isConnected) {
                const wsMessage = {
                    action: 'message',
                    roomCode: currentRoom,
                    ...message
                };
                console.log('üì§ Sending via WebSocket (fallback):', wsMessage);
                ws.send(JSON.stringify(wsMessage));
            } else {
                // Last resort: localStorage (local only)
                console.log('üíæ Sending via localStorage (local only):', message);
                localStorage.setItem('av-tester-sync', JSON.stringify({
                    roomCode: currentRoom,
                    ...message
                }));
            }
        }

        function handleSyncMessage(message) {
            console.log('Received sync:', message);

            const video = document.getElementById('test-video');
            const videoUrl = document.getElementById('video-url');

            // Handle full state synchronization (for late joiners)
            if (message.syncAction === 'sync-state') {
                console.log('üîÑ Syncing to current playback state:', message);

                // Load the media
                videoUrl.value = message.url;
                video.src = message.url;

                // Wait for metadata to load, then seek and play/pause
                video.addEventListener('loadedmetadata', function onLoaded() {
                    video.removeEventListener('loadedmetadata', onLoaded);

                    // Seek to current position
                    video.currentTime = message.currentTime;
                    console.log(`‚è© Seeked to ${message.currentTime.toFixed(2)}s`);

                    // Match play/pause state
                    if (message.isPlaying) {
                        video.play().then(() => {
                            console.log('‚ñ∂Ô∏è Playing in sync with other devices');
                        }).catch(err => {
                            console.warn('Auto-play blocked by browser:', err);
                            alert('Click anywhere to start playback (browser autoplay policy)');
                            document.body.addEventListener('click', () => {
                                video.play();
                            }, { once: true });
                        });
                    } else {
                        console.log('‚è∏Ô∏è Paused in sync with other devices');
                    }
                }, { once: true });

                return;
            }

            // Handle regular sync commands
            if (message.syncAction === 'load') {
                videoUrl.value = message.url;
                video.src = message.url;
            }
            if (message.syncAction === 'play') video.play();
            if (message.syncAction === 'pause') video.pause();
        }

        // Handle localStorage sync events (fallback mode)
        function handleStorageSync(e) {
            if (e.key !== 'av-tester-sync') return;
            const message = JSON.parse(e.newValue);
            if (message.roomCode !== currentRoom) return;
            handleSyncMessage(message);
        }

        // Chicago Time Display
        function updateChicagoTime() {
            const now = new Date();
            const chicagoTime = now.toLocaleString('en-US', {
                timeZone: 'America/Chicago',
                hour12: true,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('chicago-time').textContent = chicagoTime + ' CT';
        }
        
        setInterval(updateChicagoTime, 1000);
        updateChicagoTime();

        // Camera functionality
        let cameraStream = null;

        async function enumerateDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();

                const cameras = devices.filter(d => d.kind === 'videoinput');
                const microphones = devices.filter(d => d.kind === 'audioinput');

                const cameraSelect = document.getElementById('camera-select');
                const micSelect = document.getElementById('microphone-select');

                cameraSelect.innerHTML = '<option value="">Select Camera...</option>';
                cameras.forEach(camera => {
                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.textContent = camera.label || `Camera ${cameraSelect.options.length}`;
                    cameraSelect.appendChild(option);
                });

                micSelect.innerHTML = '<option value="">Select Microphone...</option>';
                microphones.forEach(mic => {
                    const option = document.createElement('option');
                    option.value = mic.deviceId;
                    option.textContent = mic.label || `Microphone ${micSelect.options.length}`;
                    micSelect.appendChild(option);
                });

            } catch (err) {
                console.error('Error enumerating devices:', err);
            }
        }

        async function startCamera() {
            try {
                const deviceId = document.getElementById('camera-select').value;
                const constraints = {
                    video: (deviceId && deviceId !== "") ? { deviceId: { exact: deviceId } } : true
                };

                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('camera-preview');
                video.srcObject = cameraStream;

                const track = cameraStream.getVideoTracks()[0];
                const settings = track.getSettings();
                document.getElementById('camera-info').textContent =
                    `Active: ${settings.width}x${settings.height} @ ${settings.frameRate}fps`;

                // Re-enumerate to get proper labels now that permission is granted
                await enumerateDevices();
            } catch (err) {
                alert('Camera error: ' + err.message);
                document.getElementById('camera-info').textContent = 'Error: ' + err.message;
            }
        }

        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                document.getElementById('camera-preview').srcObject = null;
                document.getElementById('camera-info').textContent = 'Camera stopped';
                cameraStream = null;
            }
        }

        // Microphone functionality
        let micStream = null;
        let audioContext = null;
        let analyser = null;
        let animationId = null;

        async function startMicrophone() {
            try {
                const deviceId = document.getElementById('microphone-select').value;
                const constraints = {
                    audio: (deviceId && deviceId !== "") ? { deviceId: { exact: deviceId } } : true
                };

                micStream = await navigator.mediaDevices.getUserMedia(constraints);

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(micStream);
                source.connect(analyser);

                analyser.fftSize = 256;
                visualizeAudio();

                const track = micStream.getAudioTracks()[0];
                const settings = track.getSettings();
                document.getElementById('mic-info').textContent =
                    `Active: ${settings.sampleRate}Hz, ${settings.channelCount} channel(s)`;

                // Re-enumerate to get proper labels now that permission is granted
                await enumerateDevices();
            } catch (err) {
                alert('Microphone error: ' + err.message);
                document.getElementById('mic-info').textContent = 'Error: ' + err.message;
            }
        }

        function stopMicrophone() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                document.getElementById('mic-info').textContent = 'Microphone stopped';
                micStream = null;
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
                const canvas = document.getElementById('audio-visualizer');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        }

        function visualizeAudio() {
            const canvas = document.getElementById('audio-visualizer');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function draw() {
                animationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                
                ctx.fillStyle = 'rgb(245, 245, 245)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;

                    // Illinois orange gradient based on amplitude
                    ctx.fillStyle = `rgba(255, 95, 5, ${0.3 + (dataArray[i] / 255) * 0.7})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

                    x += barWidth + 1;
                }
            }
            
            draw();
        }

        // Video sync functions
        function loadVideo() {
            const url = document.getElementById('video-url').value;
            if (!url) {
                alert('Please enter a video URL');
                return;
            }
            document.getElementById('test-video').src = url;
            broadcastSync('load', 'video', { url });
        }

        function syncPlay() {
            const video = document.getElementById('test-video');
            if (!video.src) {
                alert('Please load video first');
                return;
            }
            video.play();
            broadcastSync('play', 'video');
        }

        function syncPause() {
            const video = document.getElementById('test-video');
            video.pause();
            broadcastSync('pause', 'video');
        }

        // Device information
        function updateDeviceInfo() {
            const info = document.getElementById('device-info');
            const ua = navigator.userAgent;
            const platform = navigator.platform;
            const language = navigator.language;
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            let html = `
                <strong>User Agent:</strong> ${ua}<br>
                <strong>Platform:</strong> ${platform}<br>
                <strong>Language:</strong> ${language}<br>
                <strong>Screen:</strong> ${window.screen.width}x${window.screen.height}<br>
                <strong>Viewport:</strong> ${window.innerWidth}x${window.innerHeight}<br>
                <strong>Color Depth:</strong> ${window.screen.colorDepth}-bit<br>
                <strong>Pixel Ratio:</strong> ${window.devicePixelRatio}<br>
            `;
            
            if (connection) {
                html += `<strong>Connection:</strong> ${connection.effectiveType || 'unknown'}<br>`;
            }
            
            info.innerHTML = html;
        }

        // Initialize
        window.addEventListener('load', () => {
            updateDeviceInfo();
            enumerateDevices();
        });

        // Auto-create room on first load
        if (!localStorage.getItem('av-tester-room')) {
            createRoom();
        } else {
            currentRoom = localStorage.getItem('av-tester-room');
            document.getElementById('room-code').textContent = currentRoom;
            connectWebSocket(currentRoom);
        }
    </script>
</body>
</html>
